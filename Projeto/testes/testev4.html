<!DOCTYPE html>
<html lang="pt">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Jogo com Controle por Gestos</title>
  <script src="https://unpkg.com/ml5@0.12.2/dist/ml5.min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 20px;
      font-family: Arial, sans-serif;
      background: #1a1a1a;
      color: white;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    
    .info-panel {
      background: rgba(255, 255, 255, 0.1);
      padding: 15px;
      border-radius: 5px;
      margin-bottom: 20px;
      max-width: 920px;
      width: 100%;
    }
    
    .info-panel h3 {
      margin-top: 0;
      color: #4a9eff;
    }
    
    .status-indicator {
      display: inline-block;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin-right: 8px;
    }
    
    .status-loading {
      background: #f39c12;
      animation: pulse 1s infinite;
    }
    
    .status-ready {
      background: #2ecc71;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    
    .game-area {
      display: flex;
      gap: 20px;
      margin-bottom: 20px;
    }
    
    #gameCanvas {
      border: 2px solid #4a9eff;
      background: #2a2a2a;
    }
    
    .video-container {
      position: relative;
    }
    
    #videoCanvas {
      border: 2px solid #4a9eff;
      background: #000;
    }
    
    .gesture-status {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.9);
      padding: 10px 15px;
      border-radius: 5px;
      font-size: 16px;
      font-weight: bold;
      z-index: 10;
    }
    
    .gesture-closed {
      color: #4a9eff;
    }
    
    .gesture-open {
      color: #f1c40f;
    }
    
    .victory-message {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      padding: 40px 60px;
      border-radius: 20px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
      text-align: center;
      z-index: 1000;
      animation: popIn 0.5s ease-out;
    }
    
    .victory-message.show {
      display: block;
    }
    
    .victory-message h1 {
      font-size: 48px;
      margin: 0 0 20px 0;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
    }
    
    .victory-message p {
      font-size: 20px;
      margin: 10px 0;
    }
    
    @keyframes popIn {
      0% {
        transform: translate(-50%, -50%) scale(0.5);
        opacity: 0;
      }
      100% {
        transform: translate(-50%, -50%) scale(1);
        opacity: 1;
      }
    }
  </style>
</head>
<body>
  <div class="info-panel">
    <h3>üéÆ Controles por Gestos + Teclado</h3>
    <p><span class="status-indicator" id="statusIndicator"></span><span id="statusText">A carregar modelo...</span></p>
    <p>‚úã <strong>M√£o Aberta</strong> = Adubar (E) | ‚úä <strong>M√£o Fechada</strong> = Regar (Q) | ‚å®Ô∏è <strong>WASD/Setas</strong> = Mover</p>
  </div>
  
  <div class="game-area">
    <canvas id="gameCanvas"></canvas>
    <div class="video-container">
      <canvas id="videoCanvas" width="320" height="240"></canvas>
      <div class="gesture-status" id="gestureStatus">Aguardando...</div>
    </div>
  </div>
  
  <div class="victory-message" id="victoryMessage">
    <h1>üéâ Parab√©ns! üéâ</h1>
    <p>Todas as √°rvores est√£o completamente crescidas!</p>
    <p>‚ú® Miss√£o Completa ‚ú®</p>
  </div>

  <script>
    
    let video;
    let handpose;
    let predictions = [];
    let videoCanvas;
    let videoCtx;
    
    let lastGesture = null;
    let gestureDebounce = 0;
    const DEBOUNCE_TIME = 30;
    
    function setupHandTracking() {
      video = document.createElement('video');
      video.width = 320;
      video.height = 240;
      video.style.display = 'none';
      document.body.appendChild(video);
      
      videoCanvas = document.getElementById('videoCanvas');
      videoCtx = videoCanvas.getContext('2d');
      
      navigator.mediaDevices.getUserMedia({ 
        video: { width: 320, height: 240 } 
      }).then(stream => {
        video.srcObject = stream;
        video.play();
        
        handpose = ml5.handpose(video, modelReady);
        handpose.on('predict', results => {
          predictions = results;
        });
      }).catch(err => {
        console.error('Erro ao acessar webcam:', err);
        document.getElementById('statusText').textContent = 'Erro: Permita acesso √† webcam';
      });
    }
    
    function modelReady() {
      console.log('Modelo handpose carregado!');
      document.getElementById('statusText').textContent = 'Sistema pronto! Mostre sua m√£o';
      document.getElementById('statusIndicator').className = 'status-indicator status-ready';
    }
    
    function distance(p1, p2) {
      return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));
    }
    
    function detectGesture(hand) {
      const landmarks = hand.landmarks;
      
      const wrist = landmarks[0];
      const thumbTip = landmarks[4];
      const indexTip = landmarks[8];
      const middleTip = landmarks[12];
      const ringTip = landmarks[16];
      const pinkyTip = landmarks[20];
      
      const thumbDist = distance(thumbTip, wrist);
      const indexDist = distance(indexTip, wrist);
      const middleDist = distance(middleTip, wrist);
      const ringDist = distance(ringTip, wrist);
      const pinkyDist = distance(pinkyTip, wrist);
      
      const avgDistance = (indexDist + middleDist + ringDist + pinkyDist) / 4;
      
      if (avgDistance > 150) {
        return 'open';
      } else if (avgDistance < 100) {
        return 'closed';
      }
      
      return 'none';
    }
    
    function simulateKeyPress(key) {
      const eventDown = new KeyboardEvent('keydown', {
        key: key,
        code: key === 'q' ? 'KeyQ' : 'KeyE',
        keyCode: key === 'q' ? 81 : 69,
        bubbles: true
      });
      
      const eventUp = new KeyboardEvent('keyup', {
        key: key,
        code: key === 'q' ? 'KeyQ' : 'KeyE',
        keyCode: key === 'q' ? 81 : 69,
        bubbles: true
      });
      
      window.dispatchEvent(eventDown);
      setTimeout(() => {
        window.dispatchEvent(eventUp);
      }, 100);
    }
    
    function drawHand() {
      videoCtx.clearRect(0, 0, videoCanvas.width, videoCanvas.height);
      
      videoCtx.save();
      videoCtx.scale(-1, 1);
      videoCtx.drawImage(video, -videoCanvas.width, 0, videoCanvas.width, videoCanvas.height);
      videoCtx.restore();
      
      if (predictions.length > 0) {
        const hand = predictions[0];
        const gesture = detectGesture(hand);
        
        const landmarks = hand.landmarks;
        videoCtx.fillStyle = '#00ff00';
        landmarks.forEach(point => {
          videoCtx.beginPath();
          videoCtx.arc(videoCanvas.width - point[0], point[1], 5, 0, 2 * Math.PI);
          videoCtx.fill();
        });
        
        videoCtx.strokeStyle = '#00ff00';
        videoCtx.lineWidth = 2;
        const connections = [
          [0, 1], [1, 2], [2, 3], [3, 4],
          [0, 5], [5, 6], [6, 7], [7, 8],
          [0, 9], [9, 10], [10, 11], [11, 12],
          [0, 13], [13, 14], [14, 15], [15, 16],
          [0, 17], [17, 18], [18, 19], [19, 20],
          [5, 9], [9, 13], [13, 17]
        ];
        
        connections.forEach(([start, end]) => {
          videoCtx.beginPath();
          videoCtx.moveTo(videoCanvas.width - landmarks[start][0], landmarks[start][1]);
          videoCtx.lineTo(videoCanvas.width - landmarks[end][0], landmarks[end][1]);
          videoCtx.stroke();
        });
        
        const statusDiv = document.getElementById('gestureStatus');
        
        if (gestureDebounce > 0) {
          gestureDebounce--;
        }
        
        if (gesture === 'open' && lastGesture !== 'open' && gestureDebounce === 0) {
          statusDiv.textContent = '‚úã M√ÉO ABERTA - ADUBAR!';
          statusDiv.className = 'gesture-status gesture-open';
          simulateKeyPress('e');
          lastGesture = 'open';
          gestureDebounce = DEBOUNCE_TIME;
        } else if (gesture === 'closed' && lastGesture !== 'closed' && gestureDebounce === 0) {
          statusDiv.textContent = '‚úä M√ÉO FECHADA - REGAR!';
          statusDiv.className = 'gesture-status gesture-closed';
          simulateKeyPress('q');
          lastGesture = 'closed';
          gestureDebounce = DEBOUNCE_TIME;
        } else if (gesture === 'none') {
          statusDiv.textContent = 'Aguardando gesto...';
          statusDiv.className = 'gesture-status';
          if (gestureDebounce === 0) {
            lastGesture = null;
          }
        }
      } else {
        document.getElementById('gestureStatus').textContent = 'Mostre sua m√£o';
      }
      
      requestAnimationFrame(drawHand);
    }
    
    document.getElementById('statusIndicator').className = 'status-indicator status-loading';
    setupHandTracking();
    setTimeout(() => drawHand(), 1000);
    
    // ==========================================
    // SEU C√ìDIGO DO JOGO (SEM ALTERA√á√ïES)
    // ==========================================
    
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    function resize() {
      canvas.width = 600;
      canvas.height = 300;
    }
    window.addEventListener('resize', resize);
    resize();

    const mapScale = 3;
    const world = {
      width: 512 * mapScale,
      height: 512 * mapScale
    };

    const camera = { x: 0, y: 0 };

    const player = {
      x: world.width / 2 - 95,
      y: world.height / 2 - 20,
      width: 32,
      height: 32,
      frameX: 0,
      frameY: 0,
      state: "idle",
      speed: 5,
      moving: false,
      facing: 1
    };

    const keys = {};
    window.addEventListener('keydown', e => keys[e.key] = true);
    window.addEventListener('keyup', e => keys[e.key] = false);

    const mapImage = new Image();
    mapImage.src = "../assets/Mapa.png";

    const sprites = {
      idle: new Image(),
      walk: new Image()
    };
    sprites.idle.src = "../assets/Idle.png";
    sprites.walk.src = "../assets/Walk.png";

    const treeSprite = new Image();
    treeSprite.src = "../assets/MapleTree.png";

    const trees = [];
    let nearbyTree = null;
    let showInteraction = false;

    let loaded = 0;
    const totalImages = 4;

    mapImage.onload = () => {
      loaded++;
      if (loaded === totalImages) startGame();
    };
    for (let key in sprites) {
      sprites[key].onload = () => {
        loaded++;
        if (loaded === totalImages) startGame();
      };
    }
    treeSprite.onload = () => {
      loaded++;
      if (loaded === totalImages) startGame();
    };

    const collisions = [];
    let tileSize = 16;

    async function loadCollisions() {
      try {
        const response = await fetch("../assets/collisions.txt");
        const text = await response.text();
        const lines = text.trim().split("\n");
        const cols = lines[0].trim().split(/\s+/).length;
        tileSize = 512 / cols;

        for (let row = 0; row < lines.length; row++) {
          const values = lines[row].trim().split(/\s+/);
          for (let col = 0; col < values.length; col++) {
            if (values[col] === "1" || values[col] === "2") {
              collisions.push({
                x: col * tileSize * mapScale, 
                y: row * tileSize * mapScale,
                w: tileSize * mapScale,
                h: tileSize * mapScale
              });
            }
          }
        }
      } catch (e) {
        console.error("Erro ao carregar colis√µes:", e);
      }
    }

    async function loadTrees() {
      try {
        const response = await fetch("../assets/collisions.txt");
        const text = await response.text();
        const lines = text.trim().split("\n");
        const cols = lines[0].trim().split(/\s+/).length;
        const treeTileSize = 512 / cols;

        for (let row = 0; row < lines.length; row++) {
          const values = lines[row].trim().split(/\s+/);
          for (let col = 0; col < values.length; col++) {
            if (values[col] === "2") {
              trees.push({
                x: col * treeTileSize * mapScale + (treeTileSize * mapScale - 32 * mapScale) / 2,
                y: row * treeTileSize * mapScale + (treeTileSize * mapScale - 32 * mapScale) / 2,
                width: 32 * mapScale,
                height: 48 * mapScale,
                stage: 0,
                growth: 0,
                growthSpeed: 0.05,
                watered: false,
                fertilized: false
              });
            }
          }
        }
      } catch (e) {
        console.error("Erro ao carregar √°rvores:", e);
      }
    }

    function rectsOverlap(a, b) {
      return !(
        a.x + a.w <= b.x ||
        a.x >= b.x + b.w ||
        a.y + a.h <= b.y ||
        a.y >= b.y + b.h
      );
    }

    function checkCollision(x, y) {
      const hitbox = {
        x: x, 
        y: y,
        w: player.width * 2,
        h: player.height * 2
      };
      for (const c of collisions) {
        if (rectsOverlap(hitbox, c)) return true;
      }
      return false;
    }

    function movePlayer() {
      let move = false;
      let newX = player.x;  
      let newY = player.y;

      if (keys["ArrowUp"] || keys["w"]) {
        newY -= player.speed;
        player.frameY = 1;
        move = true;
      }
      if (keys["ArrowDown"] || keys["s"]) {
        newY += player.speed;
        player.frameY = 0;
        move = true;
      }
      if (keys["ArrowLeft"] || keys["a"]) {
        newX -= player.speed;
        player.frameY = 2;
        move = true;
        player.facing = -1;
      }
      if (keys["ArrowRight"] || keys["d"]) {
        newX += player.speed;
        player.frameY = 2;
        move = true;
        player.facing = 1;
      }

      if (!checkCollision(newX, player.y)) player.x = newX;
      if (!checkCollision(player.x, newY)) player.y = newY;

      player.moving = move;
      player.state = move ? "walk" : "idle";

      if (player.x < 0) player.x = 0; 
      if (player.y < 0) player.y = 0; 
      if (player.x + 64 > world.width) player.x = world.width - 64; 
      if (player.y + 64 > world.height) player.y = world.height - 64;
    }

    function checkTreeProximity() {
      nearbyTree = null;
      showInteraction = false;

      for (const tree of trees) {
        const dist = Math.hypot(
          (player.x + 32) - (tree.x + tree.width / 2),
          (player.y + 32) - (tree.y + tree.height / 2)
        );

        if (dist <= 60) {
          nearbyTree = tree;
          showInteraction = true;
          break;
        }
      }
    }

    function updateTrees() {
      trees.forEach((tree) => {
        if (tree.stage < 3) {
          let speed = tree.growthSpeed;
          
          if (tree.watered) speed *= 2;
          if (tree.fertilized) speed *= 100;

          tree.growth += speed;
          if (tree.growth >= 100 && tree.stage < 3) {
            tree.growth = 0;
            tree.stage++;
            tree.watered = false;
            tree.fertilized = false;
          }
        }
      });
    }

    function updateProgressBars() {
      trees.forEach((tree, index) => {
        const progressBar = document.getElementById(`progress-${index}`);
        const stageText = document.getElementById(`stage-${index}`);
        
        if (progressBar && stageText) {
          progressBar.style.width = `${tree.growth}%`;
          stageText.textContent = `Est√°gio: ${tree.stage + 1}/4`;

          if (tree.stage === 3) {
            progressBar.style.background = '#00ff00';
            progressBar.style.boxShadow = '0 0 10px rgba(241, 196, 15, 0.8)';
          }
        }
      });
    }

    function interactTree(action) {
      if (!nearbyTree) return;

      if (action === 'water') { 
        nearbyTree.watered = true;
      } else if (action === 'fertilize') {
        nearbyTree.fertilized = true;
      }
      showInteraction = false;
    }

    const keyPressed = {};

    window.addEventListener('keydown', (e) => {
      if (keyPressed[e.key]) return;
      keyPressed[e.key] = true;

      if (!showInteraction || !nearbyTree) return;

      if (e.key === 'q' || e.key === 'Q') {
        interactTree('water');
      }
      
      if (e.key === 'e' || e.key === 'E') {
        interactTree('fertilize');
      }
    });

    window.addEventListener('keyup', (e) => {
      keyPressed[e.key] = false;
    });

    function updateCamera() {
      camera.x = player.x - canvas.width / 2 + 32;
      camera.y = player.y - canvas.height / 2 + 32;

      if (camera.x < 0) camera.x = 0; 
      if (camera.y < 0) camera.y = 0; 
      if (camera.x + canvas.width > world.width)  
        camera.x = world.width - canvas.width;
      if (camera.y + canvas.height > world.height)
        camera.y = world.height - canvas.height;
    }

    let frameCount = 0;
    function animateFrame() { 
      frameCount++;
      if (frameCount % 10 === 0) {
        player.frameX = (player.frameX + 1) % 3;
      }
    }

    function drawWorld() {
      if (!mapImage.complete) return;
      ctx.drawImage(
        mapImage,
        0,
        0,
        512, 
        512,
        -camera.x, 
        -camera.y,
        world.width, 
        world.height
      );
    }

    function drawTrees() {
      if (!treeSprite.complete) return;

      trees.forEach(tree => {
        const screenX = tree.x - camera.x;
        const screenY = tree.y - camera.y;

        if (screenX + tree.width >= 0 && screenX <= canvas.width &&
            screenY + tree.height >= 0 && screenY <= canvas.height) {
          
          const spriteX = tree.stage * 32;
          
          ctx.drawImage(
            treeSprite,
            spriteX, 
            0,
            32, 
            48,
            screenX + 24, 
            screenY - 24,
            tree.width, 
            tree.height
          );
        }
      });
    }

    function drawPlayer() {
      const img = sprites[player.state];
      if (!img.complete) return;

      const screenX = player.x - camera.x;  
      const screenY = player.y - camera.y;

      ctx.save();
      if (player.facing === -1) {
        ctx.translate(screenX + 64, screenY);
        ctx.scale(-1, 1);
        ctx.drawImage(
          img,
          player.frameX * player.width,
          player.frameY * player.height,
          player.width,
          player.height,
          -32,
          0,
          player.width * 3,
          player.height * 3
        );
      } else {
        ctx.drawImage(
          img,
          player.frameX * player.width,
          player.frameY * player.height,
          player.width,
          player.height,
          screenX,
          screenY,
          player.width * 3,
          player.height * 3
        );
      }
      ctx.restore();
    }

    function drawInteractionMenu() {
      if (!showInteraction) return;

      const menuWidth = 240;
      const menuHeight = 50;
      const menuX = canvas.width / 2 - menuWidth / 2;
      const menuY = canvas.height - 50;

      ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
      ctx.fillRect(menuX, menuY, menuWidth, menuHeight);

      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 2;
      ctx.strokeRect(menuX, menuY, menuWidth, menuHeight);

      ctx.fillStyle = '#4a9eff';
      ctx.fillRect(menuX + 10, menuY + 5, 100, 40);
      ctx.strokeRect(menuX + 10, menuY + 5, 100, 40);

      ctx.fillStyle = '#502d14e6';
      ctx.fillRect(menuX + 130, menuY + 5, 100, 40);
      ctx.strokeRect(menuX + 130, menuY + 5, 100, 40);

      ctx.fillStyle = '#fff';
      ctx.font = '16px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('Q Regar', menuX + 60, menuY + 30);
      ctx.fillText('E Adubar', menuX + 180, menuY + 30);
    }

    // VERIFICA√á√ÉO DE VIT√ìRIA
    let victoryShown = false;
    
    function checkVictory() {
      if (trees.length > 0) {
        const allGrown = trees.every(tree => tree.stage === 3);
        
        if (allGrown && !victoryShown) {
          document.getElementById('victoryMessage').classList.add('show');
          victoryShown = true;
          
          setTimeout(() => {
            document.getElementById('victoryMessage').classList.remove('show');
          }, 5000);
        }
      }
    }

    function loop() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      movePlayer();
      updateCamera();
      animateFrame();
      checkTreeProximity();
      updateTrees();
      updateProgressBars(); 
      checkVictory(); // NOVA FUN√á√ÉO
      drawWorld();
      drawTrees();
      drawPlayer();
      drawInteractionMenu();
      requestAnimationFrame(loop);
    } 

    async function startGame() {
      await loadCollisions();
      await loadTrees();
      requestAnimationFrame(loop);
    }

  </script>
</body>
</html>